from collections import defaultdict, deque
from typing import Dict, Set, Tuple, List
import tkinter as tk
from tkinter import ttk, messagebox


# Онтологія даних
IS_A_EDGES: Set[Tuple[str, str]] = {
    ("їжа", "сутність"), 
    ("інгредієнт", "їжа"), 
    ("страва", "їжа"),
    ("овоч", "інгредієнт"), 
    ("фрукт", "інгредієнт"), 
    ("м'ясо", "інгредієнт"), 
    ("молочний_продукт", "інгредієнт"),
    ("морква", "овоч"), 
    ("томат", "овоч"), 
    ("лимон", "фрукт"), 
    ("полуниця", "фрукт"),
    ("яловичина", "м'ясо"), 
    ("курка", "м'ясо"), 
    ("сир", "молочний_продукт"), 
    ("молоко", "молочний_продукт"),
    ("тісто", "інгредієнт"),
    ("піца", "страва"), 
    ("борщ", "страва"), 
    ("торт", "страва"),
    ("кухня", "сутність"),
}

PART_OF_EDGES = {
    ("томат", "піца"), ("сир", "піца"), ("тісто", "піца"), 
    ("морква", "борщ"), ("яловичина", "борщ"),
    ("тісто", "торт"), ("молоко", "торт")
}

BELONGS_TO_EDGES = {
    ("піца", "італійська_кухня"), 
    ("борщ", "українська_кухня"), 
    ("торт", "французька_кухня")
}

INSTANCES = {
    "carrot_1": "морква", "carrot_2": "морква", 
    "tomato_1": "томат", "tomato_2": "томат",
    "lemon_1": "лимон", "lemon_2": "лимон", 
    "strawberry_1": "полуниця", "strawberry_2": "полуниця",
    "beef_1": "яловичина", "beef_2": "яловичина", 
    "chicken_1": "курка", "chicken_2": "курка",
    "cheese_1": "сир", "cheese_2": "сир", 
    "milk_1": "молоко", "milk_2": "молоко",
    "pizza_1": "піца", "pizza_2": "піца", 
    "borscht_1": "борщ", "borscht_2": "борщ", 
    "cake_1": "торт", "cake_2": "торт",
    "італійська_кухня": "кухня", 
    "українська_кухня": "кухня", 
    "французька_кухня": "кухня",
}


ISA_CHILDREN_INDEX: Dict[str, Set[str]] = defaultdict(set)
ISA_PARENTS_INDEX: Dict[str, Set[str]] = defaultdict(set)
for child, parent in IS_A_EDGES:
    ISA_CHILDREN_INDEX[parent].add(child)
    ISA_PARENTS_INDEX[child].add(parent)

# Побудова графа знань
def build_labeled_edges() -> List[Tuple[str, str, str]]:
    edges = []
    # is_a зв'язки
    for child, parent in IS_A_EDGES:
        edges.append((child, parent, "is_a"))
        edges.append((parent, child, "is_a↑"))
    # part_of зв'язки
    for part, whole in PART_OF_EDGES:
        edges.append((part, whole, "part_of"))
        edges.append((whole, part, "has_part"))
    # belongs_to зв'язки
    for dish, cuisine in BELONGS_TO_EDGES:
        edges.append((dish, cuisine, "belongs_to"))
        edges.append((cuisine, dish, "has_cuisine"))
    # Інстанси
    for inst, cls in INSTANCES.items():
        edges.append((inst, cls, "instance"))
        edges.append((cls, inst, "class_of"))
    return edges

LABELED_EDGES = build_labeled_edges()


LABELS_UA: Dict[str, str] = {
    "is_a": "є підкласом", "is_a↑": "є суперкласом", 
    "part_of": "є частиною", "has_part": "має частину",
    "belongs_to": "належить до кухні", "has_cuisine": "містить страву",
    "instance": "є екземпляром", "class_of": "є класом для",
}

# Основні функції
def normalize_id(text: str) -> str:
    return text.strip().strip('"').strip("'").lower().replace(" ", "_")

def is_subclass_of(child: str, parent: str) -> bool:
    if child == parent:
        return True
    for direct_parent in ISA_PARENTS_INDEX.get(child, ()):
        if is_subclass_of(direct_parent, parent):
            return True
    return False

def find_labeled_path(src: str, dst: str) -> List[Tuple[str, str | None]]:
    if src == dst:
        return [(src, None)]
    visited = {src}
    queue = deque([(src, [])])
    while queue:
        current_node, path = queue.popleft()
        for edge_src, edge_dst, edge_label in LABELED_EDGES:
            if edge_src != current_node or edge_dst in visited:
                continue
            new_path = path + [(edge_src, edge_label)]
            if edge_dst == dst:
                return new_path + [(edge_dst, None)]
            visited.add(edge_dst)
            queue.append((edge_dst, new_path))
    return []

def explain_relationship(a: str, b: str) -> str:
    a_norm, b_norm = normalize_id(a), normalize_id(b)
    a_norm = ALIASES.get(a_norm, a_norm)
    b_norm = ALIASES.get(b_norm, b_norm)

    # Перевірка наявності об'єктів в онтології
    all_nodes = {c for c, p in IS_A_EDGES} | {p for c, p in IS_A_EDGES}
    all_nodes |= {p for p, _ in PART_OF_EDGES} | {w for _, w in PART_OF_EDGES}
    all_nodes |= {d for d, _ in BELONGS_TO_EDGES} | {c for _, c in BELONGS_TO_EDGES}
    all_nodes |= set(INSTANCES.keys()) | set(INSTANCES.values())

    if a_norm not in all_nodes:
        return f'Обʼєкт "{a}" не знайдено в базі знань.'
    if b_norm not in all_nodes:
        return f'Обʼєкт "{b}" не знайдено в базі знань.'

    path = find_labeled_path(a_norm, b_norm)
    if not path:
        return f'Чи "{a_norm}" пов’язана з "{b_norm}"? — Хиба.'
    
    # Форматування результату
    nodes = [node for node, _ in path]
    chain = " → ".join(nodes)
    steps = []
    for i in range(len(path) - 1):
        node, edge_label = path[i]
        next_node = path[i + 1][0]
        steps.append(f"  {i+1}) {node} -({LABELS_UA.get(edge_label, edge_label)})-> {next_node}")
    
    return (f'Чи "{a_norm}" пов’язана з "{b_norm}"? — Істина.\n'
            f'Шлях: {chain}\nКроки:\n' + "\n".join(steps))


def is_part_of_transitive(part: str, whole: str) -> bool:
    part_norm, whole_norm = normalize_id(part), normalize_id(whole)
    candidates = {part_norm}
    queue = deque([part_norm])
    while queue:
        current = queue.popleft()
        for subclass in ISA_CHILDREN_INDEX.get(current, []):
            if subclass not in candidates:
                candidates.add(subclass)
                queue.append(subclass)
        for inst, cls in INSTANCES.items():
            if cls == current:
                candidates.add(inst)
    
    visited = set()
    queue = deque(candidates)
    while queue:
        current = queue.popleft()
        if current in visited:
            continue
        visited.add(current)
        for p, w in PART_OF_EDGES:
            if p == current:
                if w == whole_norm:
                    return True
                queue.append(w)
    return False

def has_part_transitive(whole: str, part: str) -> bool:
    whole_norm, part_norm = normalize_id(whole), normalize_id(part)
    for p, w in PART_OF_EDGES:
        if w == whole_norm:
            if p == part_norm or is_subclass_of(p, part_norm) or is_subclass_of(part_norm, p):
                return True
    # Транзитивна перевірка
    visited = {whole_norm}
    queue = deque([whole_norm])
    while queue:
        current = queue.popleft()
        for p, w in PART_OF_EDGES:
            if w == current and p not in visited:
                if p == part_norm or is_subclass_of(p, part_norm) or is_subclass_of(part_norm, p):
                    return True
                visited.add(p)
                queue.append(p)
    return False

def is_belongs_to_direct(dish: str, cuisine: str) -> bool:
    dish_norm = normalize_id(dish)
    cuisine_norm = ALIASES.get(normalize_id(cuisine), normalize_id(cuisine))
    return (dish_norm, cuisine_norm) in BELONGS_TO_EDGES


ALIASES: Dict[str, str] = {
    "живий": "організм", "жива": "організм", "живою": "організм",
    "їстівний": "їжа", "їстівна": "їжа", "їстівне": "їжа", "їстівною": "їжа",
    "італійської_кухні": "італійська_кухня",
    "української_кухні": "українська_кухня", 
    "французької_кухні": "французька_кухня",
}

# GUI
class OntologyApp(tk.Tk):
    def __init__(self) -> None:
        super().__init__()
        self.title("Кулінарна Онтологія")
        self.geometry("600x600")
        notebook = ttk.Notebook(self)
        notebook.pack(fill="both", expand=True, padx=10, pady=10)
        self.tab_relations = ttk.Frame(notebook)
        notebook.add(self.tab_relations, text="Ручна перевірка")
        self._build_relations_tab()

    def _build_relations_tab(self):
        frame = ttk.Frame(self.tab_relations)
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        input_frame = ttk.Frame(frame)
        input_frame.grid(row=0, column=0, sticky="w")
        ttk.Label(input_frame, text="A:").pack(side="left")
        self.input_a = ttk.Entry(input_frame, width=25)
        self.input_a.pack(side="left", padx=4)
        ttk.Label(input_frame, text="B:").pack(side="left")
        self.input_b = ttk.Entry(input_frame, width=25)
        self.input_b.pack(side="left", padx=4)
        ttk.Button(input_frame, text="Пояснити", command=self.on_explain).pack(side="left", padx=6)
       
        button_frame = ttk.Frame(frame)
        button_frame.grid(row=1, column=0, sticky="w", pady=5)
        ttk.Button(button_frame, text="Перевірити is_a(A,B)", command=self.on_check_isa).pack(side="left", padx=4)
        ttk.Button(button_frame, text="A є частиною B", command=self.on_check_partof).pack(side="left", padx=4)
        ttk.Button(button_frame, text="A має частину B", command=self.on_check_haspart).pack(side="left", padx=4)
        ttk.Button(button_frame, text="A належить до B кухні", command=self.on_check_belongs).pack(side="left", padx=4)
        # Вікно виводу
        self.relations_output = tk.Text(frame, height=18, wrap="word")
        self.relations_output.grid(row=2, column=0, sticky="nsew", pady=(10, 0))
        frame.rowconfigure(2, weight=1)
        frame.columnconfigure(0, weight=1)

    def on_explain(self):
        a = self.input_a.get().strip()
        b = self.input_b.get().strip()
        if not a or not b:
            messagebox.showinfo("Підказка", "Заповніть обидва поля A і B")
            return
        self.relations_output.delete("1.0", "end")
        self.relations_output.insert("1.0", explain_relationship(a, b))

    def on_check_isa(self):
        a = normalize_id(self.input_a.get())
        b = normalize_id(self.input_b.get())
        a_class = INSTANCES.get(a, a)
        ok = (a == b) or is_subclass_of(a, b) or is_subclass_of(a_class, b)
        msg = f'Гіпотеза: "{a} є {b}" → ' + ("Істина\n\n" + explain_relationship(a, b) if ok else "Хиба")
        self.relations_output.delete("1.0", "end")
        self.relations_output.insert("1.0", msg)

    def on_check_partof(self):
        a = self.input_a.get()
        b = self.input_b.get()
        ok = is_part_of_transitive(a, b)
        msg = f'Гіпотеза: "{a} є частиною {b}" → ' + ("Істина\n\n" + explain_relationship(a, b) if ok else "Хиба")
        self.relations_output.delete("1.0", "end")
        self.relations_output.insert("1.0", msg)

    def on_check_haspart(self):
        a = self.input_a.get()
        b = self.input_b.get()
        ok = has_part_transitive(a, b)
        msg = f'Гіпотеза: "{a} має частину {b}" → ' + ("Істина\n\n" + explain_relationship(a, b) if ok else "Хиба")
        self.relations_output.delete("1.0", "end")
        self.relations_output.insert("1.0", msg)

    def on_check_belongs(self):
        a = self.input_a.get()
        b = self.input_b.get()
        ok = is_belongs_to_direct(a, b)
        msg = f'Гіпотеза: "{a} належить до {b}" → ' + ("Істина\n\n" + explain_relationship(a, b) if ok else "Хиба")
        self.relations_output.delete("1.0", "end")
        self.relations_output.insert("1.0", msg)

if __name__ == "__main__":
    OntologyApp().mainloop()
